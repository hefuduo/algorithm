/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package kotlinimpl

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors

class App {
    val greeting: String
        get() {
            return "Hello world."
        }
}

fun main(args: Array<String>) {
    val countDownLatch = CountDownLatch(2)
    val a = A(countDownLatch)
    val b = B(countDownLatch)
    val threadPool = Executors.newFixedThreadPool(4)
    threadPool.submit(a)
    threadPool.submit(b)
    countDownLatch.await()
    println("end");
}


fun <E> revserSingleOriententList(head: Node<E>?) {
    var newHead = Node<E>(null, null, null)
    var cur = head
    while (cur != null) {
        var temp = cur.next
        cur.next = newHead
        newHead = cur
        cur = temp
    }
    newHead.printList()
}

fun test() {
    val head: Node<Int>? = Node(0, null, null)
    var x = head
    for (i in 1..9) {
        x?.next = Node(i, null, null)
        x = x?.next
    }
    revserSingleOriententList(head)
}

class A(val countDownLatch: CountDownLatch) : Runnable{
    override fun run() {
        try {
            Thread.sleep(2000)
        } catch (e: Exception) {
        } finally {
            println("A run out")
            countDownLatch.countDown()
        }
    }
}


class B(val countDownLatch: CountDownLatch) : Runnable {
    override fun run() {
        try {
            Thread.sleep(1000);
        } catch (e: Exception) {
        } finally {
            println("B run out")
            countDownLatch.countDown()
        }
    }

}
